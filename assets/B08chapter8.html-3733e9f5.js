import{_ as c,o,c as i,d,a as e}from"./app-3173a81e.js";const a={},r=d('<h2 id="广播机制的概述" tabindex="-1"><a class="header-anchor" href="#广播机制的概述" aria-hidden="true">#</a> 广播机制的概述</h2><p>通常情况下在学校的每个教室都会装有一个喇叭，这些喇叭是接入到学校广播室的。如果有重要通知，会发送一条广播来告知全校师生。为了便于发送和接收系统级别的消息通知，<code>Android</code> 系统也引入了一套类似广播的消息机制。</p><p><code>Android</code> 中的广播（ <code>Broadcast</code> ）机制用于进程/线程间通信，该机制使用了观察者模式，观察者模式是一种软件设计模式，该模式是基于消息的发布/订阅事件模型，该模型中的消息发布者是广播机制中的广播发送者，消息订阅者是广播机制中的广播接收者，广播机制的具体实现流程。</p><p>广播机制的实现流程：</p><ol><li>广播接收者是通过 <code>Binder</code> 机制在 <code>AMS</code> （ <code>Activity Manager Service</code> ）中进行注册的</li><li>广播发送者是通过 <code>Binder</code> 机制向 <code>AMS</code> 发送广播</li><li><code>AMS</code> 查找符合相应条件（IntentFilter/Permission）的广播接收者 （BroadcastReceiver），将广播发送到相应的消息循环队列中</li><li>执行消息循环时获取到此广播，会回调广播接收者（ <code>BroadcastReceiver</code> ）中的 <code>onReceive()</code> 方法并在该方法中进行相关处理</li></ol><h2 id="广播接收者" tabindex="-1"><a class="header-anchor" href="#广播接收者" aria-hidden="true">#</a> 广播接收者</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><ul><li><code>Android</code> 系统中内置了很多广播，例如手机开机完成、电池电量不足时都会发送一条广播</li><li>为了监听来自系统或者应用程序的广播事件，<code>Android </code>系统提供了 <code>BroadcastReceiver</code> （广播接收者）组件</li><li>当 <code>Android</code> 系统产生一个广播事件时，可以有多个对应的广播接收者接收并进行处理</li></ul><h3 id="创建" tabindex="-1"><a class="header-anchor" href="#创建" aria-hidden="true">#</a> 创建</h3><ol><li>通过在应用程序的包中创建一个类继承 <code>BroadcastReceiver</code> 并重写 <code>onReceive()</code> 方法来实现的</li><li>通过选中应用程序中的包，右击选择 <code>New</code> → <code>Other</code> → <code>Broadcast Receiver</code> 选项来创建的</li></ol>',10),t=e("div",{class:"custom-container tip"},[e("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[e("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[e("circle",{cx:"12",cy:"12",r:"9"}),e("path",{d:"M12 8h.01"}),e("path",{d:"M11 12h1v4h1"})])]),e("p",{class:"custom-container-title"},"注意"),e("p",null,"创建完广播接收者之后还需要对广播接收者进行注册才可以接收广播。")],-1),l=d('<h2 id="自定义广播与广播的类型" tabindex="-1"><a class="header-anchor" href="#自定义广播与广播的类型" aria-hidden="true">#</a> 自定义广播与广播的类型</h2><h3 id="自定义广播" tabindex="-1"><a class="header-anchor" href="#自定义广播" aria-hidden="true">#</a> 自定义广播</h3><ul><li>当系统提供的广播不能满足实际需求时，可以自定义广播，同时需要编写对应的广播接收者。</li><li>当自定义广播发送消息时，会储存到公共消息区中，而公共消息区中如果存在对应的广播接收者，就会及时的接收这条信息。</li></ul><h3 id="广播的类型" tabindex="-1"><a class="header-anchor" href="#广播的类型" aria-hidden="true">#</a> 广播的类型</h3><ul><li>无序广播：无序广播是完全异步执行，发送广播时所有监听这个广播的广播接收者都会接收到此消息，但接收的顺序不确定。</li><li>有序广播：按照接收者的优先级接收，只有一个广播接收者能接收消息，在此广播接收者中逻辑执行完毕后，才会继续传递。</li></ul>',5),n=[r,t,l];function h(s,u){return o(),i("div",null,n)}const _=c(a,[["render",h],["__file","B08chapter8.html.vue"]]);export{_ as default};
